DDOTS RESTful API Server
========================

This project aims to provide RESTful (HTTP) API for DDOTS (Dockerized
Distributed Olympiad Testing System).

We use Swagger.io to present an interactive documentation, so run the server
and proceed to http://127.0.0.1:5000/v1/spec.html


Clone the Project
-----------------

```bash
$ git clone --recurse-submodules https://github.com/frol/ddots-api-server.git
```


Setup Environment
-----------------

It is recommended to use Docker, virtualenv, or Anaconda/Miniconda to manage
Python dependencies. Please, learn details yourself. Docker image will be
probably available later.

You will need `invoke` package to work with everything related to this project.

```bash
$ pip install invoke
```

Once you have invoke, you can learn all available commands related to this
project from:

```bash
$ invoke --list
```

Invoke tasks will prepare automatically everything that is required once you
run the application server.


Run Server
----------

```bash
$ invoke app.run
```


Run SeaweedFS
-------------

DDOTS API Server uses [SeaweedFS](https://github.com/chrislusf/seaweedfs) to
store tests for problems and solution source codes. Thus, SeaweedFS is
required.

You may run SeaweedFS locally following
[the official documentation](https://github.com/chrislusf/seaweedfs#example-usage),
or you may use Docker containers, in which case you may use Docker Compose
(its config is in `deploy/docker-compose.yml`).


Run DDOTS with SeaweedFS in Docker Containers
---------------------------------------------

You should have Docker and Docker Compose installed on your computer. Once that
is in place, run the following commands:

```bash
$ cd ./deploy
$ docker-compose up --build
```

You will need to edit `deploy/docker-compose.yml` if you want to enable
persistent storage (otherwise, updating/recreating Docker containers will wipe
all the data). Follow the instructions in the `docker-compose.yml` file.


Quickstart
----------

Open online interactive API documentation:
http://127.0.0.1:5000/api/v1/

Autogenerated swagger config is always available from
http://127.0.0.1:5000/api/v1/swagger.json


Tipical Workflow
----------------

The key components of DDOTS API Server are Solutions and Problems.

### Problems

The first thing you want to do is to create a new Problem. To do that, you need
to use the `POST /problems/` endpoint and provide a title and `.tar.gz` archive
with tests.  The `.tar.gz` archive MUST contain `Problem.xml` file in the root
and all the related files referenced from the `Problem.xml`, e.g.:

```xml
<?xml version="1.0" encoding="windows-1251"?>
<!-- Problem exchange format 0.1 -->
<Problem
   TimeLimit="0.2"
   MemoryLimit="64"
   InputFile="stdin"
   OutputFile="stdout"
   PatcherExe="patch"
   CheckerExe="check"
   TestCount="2"
   PointsOnGold="100">
    <Test Input="1.in" Answer="1.out" Points="1" />
    <Test Input="2.in" Answer="2.out" Points="1" />
</Problem>
```

Notes:

* `TimeLimit` is specified in seconds (float type value).
* `MemoryLimit` is specified in megabytes (integer).
* `InputFile` / `OutputFile` are names of input/output files or special
  `stdin`/`stdout` consts can be used.
* `PatcherExe` is optional, and its purpose is to patch the user solution on
  the compilation step of the fly (the solution that is being tested is sent to
  the patcher stdin, and the new [potentially patched] solution is expected
  from the patcher stdout).
* `CheckerExe` should have a permission to be executed and it might be either a
  statically linked binary or
  [Bourne shell](https://en.wikipedia.org/wiki/Bourne_shell) script, which
  would accept 3 parameters: test input file, solution answer file, and correct
  test answer file, and exit with exit code `0` if OK, `1` if WA (Wrong
  Answer), `2` if PE (Presentation Error).

You may want to download an example problem tests archive:
[example-problem-tests-archive.tar.gz](./docs/source/problems/example-problem-tests-archive.tar.gz)

Once you have the tests archive, you can register a new problem in the system.
There are four ways to achive that:

* Using DDOTS API Server internals:

    ```python
    from app.extensions import db
    from app.modules.problems.model import Problem

    with db.session.begin():
        db.session.add(
            Problem(
                creator_id=1,
                title="New Problem",
                tests_archive=open('problem-tests-archive.tar.gz')
            )
        )
    ```
* Using the built-in Swagger UI (http://127.0.0.1:5000/api/v1/), navigate to
  "Problems" -> "Create a new problem", and fill the form (don't forget to
  authenticate)
* Using a generated API client (Python):

    ```python
    import ddots_client

    config = ddots_client.Configuration()
    config.host = 'http://127.0.0.1:5000/api/v1'
    config.oauth2_url = 'http://127.0.0.1:5000/auth/oauth2'

    import os; os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'
    config.get_oauth2_token(client_id='internal', client_secret='Dc5NmZmMjIzODVlZDAwNjQxNmE1NDNkMmYxNjI4N2MwY2E0NjhiMzN')

    problems_api = ddots_client.ProblemsApi(ddots_client.ApiClient(config))

    print("New Problem response:")
    print(problems_api.create_problem(title="New Problem", tests_archive='problem-tests-archive.tar.gz'))
    ```
* Using cURL:

    ```bash
    ACCESS_TOKEN="$(curl --silent 'http://127.0.0.1:5000/auth/oauth2/token?grant_type=client_credentials' --user 'internal:Dc5NmZmMjIzODVlZDAwNjQxNmE1NDNkMmYxNjI4N2MwY2E0NjhiMzN' | sed -E 's/.*access_token": "([^"]+).*/\1/')"
    curl -X POST \
        --header 'Accept: application/json' \
        --header "Authorization: Bearer $ACCESS_TOKEN" \
        -F 'title=New Problem' \
        -F 'tests_archive=@problem-tests-archive.tar.gz' \
        'http://127.0.0.1:5000/api/v1/problems/'
    ```

The expected output is JSON of the following structure:

```json
{
    "id": 1,
    "title": "New Problem",
    "description": "",
    "created": "2017-06-04T08:30:51.582997+00:00",
    "updated": "2017-06-04T08:30:51.583019+00:00"
}
```

### Solutions

Similarly to the Problems, you can add new solutions into the system:

* Using direct interaction with internals (SQLAlchemy models):

    ```python
    from app.extensions import db
    from app.modules.solutions.model import Solution

    with db.session.begin():
        db.session.add(
            Solution(
                author_id=1,
                problem_id=1,
                programming_language_name='39',  # Delphi
                testing_mode='full',  # Other options: "one", "first_fail"
                source_code="""begin writeln('Hello World!'); end."""
            )
        )
    ```
* Using the built-in Swagger UI (http://127.0.0.1:5000/api/v1/), navigate to
  "Solutions" -> "Upload a new solution", and fill the form (don't forget to
  authenticate)
* Using a generated API client (Python):

    ```python
    import ddots_client

    config = ddots_client.Configuration()
    config.host = 'http://127.0.0.1:5000/api/v1'
    config.oauth2_url = 'http://127.0.0.1:5000/auth/oauth2'

    import os; os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'
    config.get_oauth2_token(client_id='internal', client_secret='Dc5NmZmMjIzODVlZDAwNjQxNmE1NDNkMmYxNjI4N2MwY2E0NjhiMzN')

    solutions_api = ddots_client.SolutionsApi(ddots_client.ApiClient(config))

    print("New Solution response:")
    print(solutions_api.send_solution(
        problem_id=1,
        programming_language_name='39',  # Delphi
        testing_mode='full',  # Other options: "one", "first_fail"
        source_code="""begin writeln('Hello World!'); end."""
    ))
    ```
* Using cURL:

    ```bash
    ACCESS_TOKEN="$(curl --silent 'http://127.0.0.1:5000/auth/oauth2/token?grant_type=client_credentials' --user 'internal:Dc5NmZmMjIzODVlZDAwNjQxNmE1NDNkMmYxNjI4N2MwY2E0NjhiMzN' | sed -E 's/.*access_token": "([^"]+).*/\1/')"
    curl -X POST \
        --header 'Accept: application/json' \
        --header "Authorization: Bearer $ACCESS_TOKEN" \
        -F 'problem_id=1' \
        -F 'programming_language_name=39' \
        -F 'testing_mode=full' \
        -F "source_code=begin writeln('Hello World!'); end." \
        'http://127.0.0.1:5000/api/v1/solutions/'
    ```

The expected output is JSON of the following structure:

```json
{
    "id": 1,
    "state": "new",
    "author": {
        "first_name": "",
        "id": 1,
        "last_name": "",
        "middle_name": "",
        "username": "internal"
    },
    "problem": {
        "id": 1,
        "title": "New Problem"
    },
    "programming_language": {
        "name": "39",
        "title": "Delphi / FreePascal",
        "version": ""
    },
    "testing_mode": "full",
    "scored_points": "0.000",
    "status": [],
    "testing_report": null,
    "created": "2017-06-04T08:57:04.634943+00:00",
    "updated": "2017-06-04T08:57:04.634965+00:00"
}
```

Use the `id` field to track the solution state and get the `testing_report`
once `state` changes to `tested`.

```bash
curl \
    --header 'Accept: application/json' \
    --header "Authorization: Bearer $ACCESS_TOKEN" \
    'http://127.0.0.1:5000/api/v1/solutions/1'
```

```json
{
    "id": 1,
    "state": "tested",
    "author": {
        "first_name": "",
        "id": 1,
        "last_name": "",
        "middle_name": "",
        "username": "internal"
    },
    "problem": {
        "id": 1,
        "title": "New Problem"
    },
    "programming_language": {
        "name": "39",
        "title": "Delphi / FreePascal",
        "version": ""
    },
    "scored_points": "100.000",
    "status": ["OK"],
    "testing_mode": "full",
    "testing_report": {
        "tests": [
            {
                "execution_time": 0.0,
                "extra": {
                    "scored_points": 1
                },
                "memory_peak": 212992.0,
                "status": "OK"
            },
            {
                "execution_time": 0.0,
                "extra": {
                    "scored_points": 99.0
                },
                "memory_peak": 0.0,
                "status": "OK"
            }
        ]
    },
    "created": "2017-06-04T08:57:04.634943+00:00",
    "updated": "2017-06-04T08:57:06.641482+00:00"
}
```

NOTE: When tests fail with WA or PE status, `extra` section contains additional
fields:

* `input` — test input file contents;
* `answer` — test answer file contents;
* `output` — solution output file (or stdout) contents.
